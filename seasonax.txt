// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/

//@version=5
indicator("SeasonaX v2", overlay=false, max_lines_count=500, max_labels_count=500)

//--------------------
// Type definitions
//--------------------
type Settings
    float           factor      = 2.75
    bool            border_show = true
    color           border_color
    bool            grid_show   = true
    color           grid_color
    bool            overlay

type YearlySettings
    bool            show
    int             ST
    color           color_1
    int             size_1
    string          style_1
    color           color_2
    int             size_2
    string          style_2
    color           color_3
    int             size_3
    string          style_3
    color           color_4
    int             size_4
    string          style_4

type Yearly
    int             year 
    float           base
    float[]         data

type YearlySet
    bool            show_1
    bool            show_2
    bool            show_3
    bool            show_4
    int             length_1
    int             length_2
    int             length_3
    int             length_4
    float           start_price
    Yearly[]        yearly1
    Yearly[]        yearly2
    Yearly[]        yearly3
    Yearly[]        yearly4

    YearlySettings  settings

//--------------------
// Vars
//--------------------
var float[] active          = array.new<float>()
var  data                   = matrix.new<float>()

var YearlySet yearlySet     = YearlySet.new()
var Yearly[] yearly1        = array.new<Yearly>()
var Yearly[] yearly2        = array.new<Yearly>()
var Yearly[] yearly3        = array.new<Yearly>()
var Yearly[] yearly4        = array.new<Yearly>()

yearlySet.yearly1           := yearly1
yearlySet.yearly2           := yearly2
yearlySet.yearly3           := yearly3
yearlySet.yearly4           := yearly4
yearlySet.settings          := YearlySettings.new()

var polyline[] lines        = array.new<polyline>()
string  group_seasonality   = "Seasonality in years"
string  group_grid          = "Grid Settings"
string  group_other         = "Other Settings"
Settings settings           = Settings.new()

//--------------------
// Inputs
//--------------------
yearlySet.show_1            := input.bool(true, "", group=group_seasonality, inline="1")
yearlySet.length_1          := input.int(5, "", group=group_seasonality, inline="1")
yearlySet.settings.color_1  := input.color(color.maroon, "", group=group_seasonality, inline="1")
yearlySet.settings.size_1   := input.int(2, "", options=[1,2,3,4], group=group_seasonality, inline="1")
// yearlySet.settings.style_1  := input.string('⎯⎯⎯', '', options = ['⎯⎯⎯', '----', '····'], group=group_seasonality, inline='1')

yearlySet.show_2            := input.bool(true, "", group=group_seasonality, inline="2")
yearlySet.length_2          := input.int(10, "", group=group_seasonality, inline="2")
yearlySet.settings.color_2  := input.color(color.navy, "", group=group_seasonality, inline="2")
yearlySet.settings.size_2   := input.int(2, "", options=[1,2,3,4], group=group_seasonality, inline="2")
// yearlySet.settings.style_2  := input.string('⎯⎯⎯', '', options = ['⎯⎯⎯', '----', '····'], group=group_seasonality, inline='2')

yearlySet.show_3            := input.bool(false, "", group=group_seasonality, inline="3")
yearlySet.length_3          := input.int(15, "", group=group_seasonality, inline="3")
yearlySet.settings.color_3  := input.color(color.olive, "", group=group_seasonality, inline="3")
yearlySet.settings.size_3   := input.int(2, "", options=[1,2,3,4], group=group_seasonality, inline="3")
// yearlySet.settings.style_3  := input.string('⎯⎯⎯', '', options = ['⎯⎯⎯', '----', '····'], group=group_seasonality, inline='3')

yearlySet.show_4            := input.bool(false, "", group=group_seasonality, inline="4")
yearlySet.length_4          := input.int(30, "", group=group_seasonality, inline="4")
yearlySet.settings.color_4  := input.color(color.teal, "", group=group_seasonality, inline="4")
yearlySet.settings.size_4   := input.int(2, "", options=[1,2,3,4], group=group_seasonality, inline="4")
// yearlySet.settings.style_4  := input.string('⎯⎯⎯', '', options = ['⎯⎯⎯', '----', '····'], group=group_seasonality, inline='4')

settings.overlay            := input.bool(false, "Add seasonality lines to chart", group=group_seasonality)

settings.border_show        := input.bool(true, "Border          ", group=group_grid, inline="1")
settings.border_color       := input.color(color.new(color.black, 0), "", group=group_grid, inline="1")
settings.grid_show          := input.bool(true, "Grid            ", group=group_grid, inline="2")
settings.grid_color         := input.color(color.new(color.black, 80), "", group=group_grid, inline="2")

settings.factor             := input.float(2.75, "Outlier Factor", minval=0, step=0.25, group=group_other, tooltip="Outlier Factor attempts to detect anomalies that are outside the norm and reset them.\n\nThe statistical standard is usually 1.5")

// Election cycle filter
cycle_filter = input.string("All", "Cycle Year Filter", options=["Pre-Election Year", "Election Year", "Post-Election Year", "Midterm Year", "All"], group=group_other)

//--------------------
// Colors & constants
//--------------------
color transparent = #00000000

//--------------------
// Helper functions
//--------------------
getMove() =>
    request.security(syminfo.tickerid, "D", ((close[1]-close[2])/close[2])*100, lookahead = barmerge.lookahead_on)

lineStyle(string style) =>
    switch style
        '----' => line.style_dashed
        '····' => line.style_dotted
        => line.style_solid

isCycleYear(_year, _type) =>
    election_base = 2024
    years_from_base = _year - election_base
    offset = (years_from_base % 4 + 4) % 4  // ensures positive 0–3
    switch _type
        "Election Year"      => offset == 0
        "Post-Election Year" => offset == 1
        "Midterm Year"       => offset == 2
        "Pre-Election Year"  => offset == 3
        "All"                => true
        => false


// Function to get year list (moved to top-level to avoid nested-function syntax error)
getYearList(_arr) =>
    if _arr.size() == 0
        ""
    string res = ""
    for i = 0 to _arr.size()-1
        res := res + (i > 0 ? ", " : "") + str.tostring(_arr.get(i).year)
    res

//--------------------
// Array methods
//--------------------
method removeOutliers(Yearly[] this) =>
    float[] temp = array.new<float>()
    for y in this
        temp.concat(y.data)
    if temp.size() > 1
        temp.sort(order.ascending)
        float q1 = temp.slice(0, temp.size()/2).median()
        float q3 = temp.slice(temp.size()/2, temp.size()).median()
        iqr = q3 - q1
        lowerBound = q1 - settings.factor * iqr
        upperBound = q3 + settings.factor * iqr
        for y in this
            for i=0 to y.data.size()-1
                if y.data.get(i) < lowerBound
                    y.data.set(i, lowerBound)
                if y.data.get(i) > upperBound
                    y.data.set(i, upperBound)
    this

method getMax(Yearly[] this) =>
    int max = 0
    for y in this
        if y.data.size() > max 
            max := y.data.size()
    max

method total(Yearly[] this) =>
    int max = this.getMax()
    float[] totals = array.new<float>()
    for i = 0 to max-1
        float average = 0
        for y in this
            if y.data.size() > i
                average += y.data.get(i)
        average := average / this.size()
        totals.push(average)
    totals

method plotgrid(YearlySet this)=>
    float[] totals1     = this.yearly1.total()
    float[] totals2     = this.yearly2.total()  
    float[] totals3     = this.yearly3.total()  
    float[] totals4     = this.yearly4.total()  
    int totals          = totals1.size()
    if totals2.size() > totals
        totals := totals2.size()
    if totals3.size() > totals
        totals := totals3.size()
    if totals4.size() > totals
        totals := totals4.size()

    int start       = bar_index - active.size()+1
    int end         = start + totals-1
    if settings.border_show
        line.new(start, 0, start, 100, color=settings.border_color)
        line.new(start, 0, end, 0, color=settings.border_color)
        line.new(end, 0, end, 100, color=settings.border_color)
        line.new(start, 100, end, 100, color=settings.border_color)
    
    if settings.grid_show
        line.new(start, 20, end, 20, style=line.style_dotted, color=color.new(color.gray, 50))
        line.new(start, 40, end, 40, style=line.style_dotted, color=color.new(color.gray, 50))
        line.new(start, 60, end, 60, style=line.style_dotted, color=color.new(color.gray, 50))
        line.new(start, 80, end, 80, style=line.style_dotted, color=color.new(color.gray, 50))
        int dt = 86400000
        var int currentYear = year(timenow)
        var int startTime = timestamp(currentYear, 1, 1, 0, 0)
        int lc = 11
        while lc > 0
            if month(startTime, "America/New_York") != month(startTime+dt, "America/New_York")
                line.new(startTime, 0,startTime, 100, xloc = xloc.bar_time, style=line.style_dotted, color=color.new(color.gray, 50))
                lc -= 1
            startTime += dt
        
        var table legend = table.new(position.bottom_right, 2, 4, bgcolor=transparent, frame_color=transparent, border_width=4)
        int row = 0
        if this.show_1
            table.cell(legend, row, 0, "█", text_color = this.settings.color_1, bgcolor = transparent, text_size=size.small)
            table.cell(legend, row, 1, getYearList(this.yearly1), bgcolor = transparent, text_size=size.small)
            row += 1
        if this.show_2
            table.cell(legend, row, 0, "█", text_color = this.settings.color_2, bgcolor = transparent, text_size=size.small)
            table.cell(legend, row, 1, getYearList(this.yearly2), bgcolor = transparent, text_size=size.small)
            row += 1
        if this.show_3
            table.cell(legend, row, 0, "█", text_color = this.settings.color_3, bgcolor = transparent, text_size=size.small)
            table.cell(legend, row, 1, getYearList(this.yearly3), bgcolor = transparent, text_size=size.small)
            row += 1
        if this.show_4
            table.cell(legend, row, 0, "█", text_color = this.settings.color_4, bgcolor = transparent, text_size=size.small)
            table.cell(legend, row, 1, getYearList(this.yearly4), bgcolor = transparent, text_size=size.small)
    this

method plot(Yearly[] this, float start_price, color c, int size, string style, bool overlay) =>
    var points   = array.new<chart.point>()
    var opoints  = array.new<chart.point>()
    float[] totals = this.total()
    int start = bar_index - active.size()+1
    var float price = start_price
    array.clear(points)
    array.clear(opoints)
    float[] temp = array.new<float>()
    temp.push(price)
    for i = 1 to totals.size() - 1
        value = totals.get(i)
        price += price*(value/100)
        temp.push(price)
    minValue = temp.min()
    maxValue = temp.max()
    for i = 0 to temp.size() - 1
        value = temp.get(i)
        nvalue = (value - minValue) / (maxValue - minValue) * 100
        idx = start + i
        points.push(chart.point.from_index(idx, nvalue))
        opoints.push(chart.point.from_index(idx, value))
    if overlay
        lines.push(polyline.new(points = opoints, line_color = c, line_width = size, line_style=lineStyle(style), force_overlay = true))
    lines.push(polyline.new(points = points, line_color = c, line_width = size, line_style=lineStyle(style), force_overlay = false))
    this

//-------------------------------------
// Main logic
//-------------------------------------
if timeframe.isdaily
    var bool done = false
    var bool start = false
    if ta.change(year)
        start := true
        done := false
        yearlySet.start_price := close
        for p in lines
            p.delete()
        // previous year contains the completed data stored in 'active'
        int prevYear = year - 1
        if active.size() > 0 and isCycleYear(prevYear, cycle_filter)
            Yearly add = Yearly.new()
            add.year := prevYear
            add.data := active.copy()
            if yearlySet.show_1
                yearlySet.yearly1.push(add.copy())
                if yearlySet.yearly1.size() > yearlySet.length_1
                    yearlySet.yearly1.remove(0)
            if yearlySet.show_2
                yearlySet.yearly2.push(add.copy())
                if yearlySet.yearly2.size() > yearlySet.length_2
                    yearlySet.yearly2.remove(0)
            if yearlySet.show_3
                yearlySet.yearly3.push(add.copy())
                if yearlySet.yearly3.size() > yearlySet.length_3
                    yearlySet.yearly3.remove(0)
            if yearlySet.show_4
                yearlySet.yearly4.push(add.copy())
                if yearlySet.yearly4.size() > yearlySet.length_4
                    yearlySet.yearly4.remove(0)
        active.clear()
    if start
        if ta.change(time("D"))
            float diff = getMove()
            active.push(diff)
    if barstate.islast and not done
        yearlySet.plotgrid()
        if yearlySet.show_1
            yearlySet.yearly1.removeOutliers().plot(yearlySet.start_price, yearlySet.settings.color_1, yearlySet.settings.size_1, yearlySet.settings.style_1, settings.overlay)
        if yearlySet.show_2
            yearlySet.yearly2.removeOutliers().plot(yearlySet.start_price, yearlySet.settings.color_2, yearlySet.settings.size_2, yearlySet.settings.style_2, settings.overlay)
        if yearlySet.show_3
            yearlySet.yearly3.removeOutliers().plot(yearlySet.start_price, yearlySet.settings.color_3, yearlySet.settings.size_3, yearlySet.settings.style_3, settings.overlay)
        if yearlySet.show_4
            yearlySet.yearly4.removeOutliers().plot(yearlySet.start_price, yearlySet.settings.color_4, yearlySet.settings.size_4, yearlySet.settings.style_4, settings.overlay)
        done := true
